 - Everything in Javascript happens inside an **Execution context**: *assume it to be a big container in which the whole code is executed*

 - It has 2 components: 
    - **Variable Environment** (Memory block)
    - **Thread of Execution** (Code block)

- **How Javascript code is executed?**

     - When below code runs a execution context is created
        var n = 2
        function sqr(num){
            var ans = num * num;
            return ans;
        }
        var square2 = sqr(2);
        var square4 = sqr(4);   //invoking fucntion twice, once for 2 and once for 4 as arguments

    - The Execution context runs in two phases as mentioned above:
        - Memory creation phase 
        - Running of actual code

- **Memory Creation Phase**
    - In this phase memory is allocated to each and every variable and functions.
    - At initial phase before code running starts all the variables are allocated with *undefined*, and in case of functions it stores the whole function.
    - For the whole function stored, later a local execution context is created for it in phase 2.
    - Memory Allocation (Phase 1)
        +-------------------+-------------------+
        | Memory            | Code              |
        +-------------------+-------------------+
        | n : undefined     |                   |
        | sqr : { ... }     |                   |
        | square2 : undef.  |                   |
        | square4 : undef.  |                   |
        +-------------------+-------------------+

- **Code Running Phase**
    - When each line of code is being executed then it starts assigning values for eg then the n=2 as per code
    - when it comes across a function it is saved at it is
    - when the function is invoked by square2 first a new local execution context is created for it. and rest procedure again uses the 2 phases for that particular function invocation.
    - Code execution (Phase 2)
        +--------------------+-----------------------------------------------+
        | Memory             | Code                                          |
        +--------------------+-----------------------------------------------+
        | n : 2              |                                               |
        | sqr : { ... }      |                                               |
        | square2 : 4   -----|-->   +-------------------+----------------+   |
        |                    |      | Memory            | Code           |   |
        |                    |      +-------------------+----------------+   |
        |                    |      | num : 2           | return ans     |   |
        |                    |      | ans : 4           |                |   |
        |                    |      +-------------------+----------------+   |   
        |                    |                                               |
        | square4 : 16  -----|-->   +-------------------+----------------+   |
        |                    |      | Memory            | Code           |   |
        |                    |      +-------------------+----------------+   |
        |                    |      | num : 4           | return ans     |   |
        |                    |      | ans : 16          |                |   |
        |                    |      +-------------------+----------------+   | 
        +--------------------+-----------------------------------------------+

    - Once the return statements from the local execution context are executed, it gets completely deleted automatically. and same happens to the global execution context when entire code is executed.

- **Call Stack**
    - What if there are alot of functions looped inside of functions, there would be so many local execution contexts inside of corresponding local execution contexts.
    - For this JS engine has something called as *call stack* that handles everything smoothly.
    - Call stack maintains the order of execution context
    - Everytime a JS program runs a global execution context is created and pushed at the very bottom of the stack.
    - while its execution if a fucntion is invoked its local execution context is stacked above it. if it is completed the local execution context is stacked out and other local execution context is pushed in if any present.
    - If the already existing local execution context has another function invocation inside it its execution context is stacked in over the already existing one and not pulled out unitl completed. and this process continues unitl the whole set of LEC are deleted.
    - Call stack is also known as: Execution context stack, Program stack, control stack, runtime stack, machine Stack.